---
layout: post
title: 「算法导论」概述
date: 2018-04-25
categories: 技术
---

## Introduction

所谓算法就是定义良好的计算过程，它取一个或一组值作为输入，并产生一个或一组输出。

## Content

* [数据结构](#数据结构)
  * 链表
     * **定义**：链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该节点还有一个元素和一个指向另一条链表的引用
     * **概念**
         * `首节点`：存放第一个有效数据的节点
         * `尾节点`：存放最后一个有效数据的节点
         * `头节点`：链表引用，用于方便链表操作
         * `头指针`：指向头节点的指针
         * `尾指针`：指向尾节点的指针
     * **结构**
         * 单链表 -- 包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值
         * 双向链表 -- 每个节点有两个连接：一个指向前一个节点，；而另一个指向下一个节点
         * 块状链表 -- 块状链表本身是一个链表，但是链表储存的并不是一般的数据，而是由这些数据组成的顺序表
     * **问题**
         * 输入一个链表，输出该链表中倒数第k个结点
         * 链表反转

  * 栈
     * **定义**：是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端进行加入数据和输出数据的运算
     * **操作**
         * 推入(push)：将数据放入堆栈的顶端，堆栈顶端top指针加一。
         * 弹出(pop)：将顶端数据数据输出，堆栈顶端数据减一
     
  * 队列
     * **定义**：是先进先出的线性表
     * **结构**
         * 单链队列
         * 循环队列
         * 阵列队列
  * 树
     * **定义**：树是一种抽象数据结构类型，用来模拟具有树状结构性质的数据集合
     * **概念**：
         * `节点的度`：一个节点含有的子树的个数称为该节点的度
         * `树的度`：一棵树中，最大的节点的度称为树的度
         * `叶节点或终端节点`：度为零的节点
         * `非终端节点或分支节点`：度不为零的节点
         * `父亲节点或父节点`：若一个节点含有子节点，则这个节点称为其子节点的父节点
         * `孩子节点或子节点`：一个节点含有的子树的根节点称为该节点的子节点
         * `兄弟节点`：具有相同父节点的节点互称为兄弟节点
         * `节点的层次`：从根开始定义起，根为第1层，根的子节点为第2层，以此类推
         * `深度`：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0
         * `高度`：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0
         * `堂兄弟节点`：父节点在同一层的节点互为堂兄弟
         * `节点的祖先`：从根到该节点所经分支上的所有节点
         * `子孙`：以某节点为根的子树中任一节点都称为该节点的子孙
         * `森林`：由m（m>=0）棵互不相交的树的集合称为森林
      * **结构**
         * 无序树
         * 有序树
             * 二叉树
             >定义：二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构<br>
             ><span style="color:red">备注：在图论中的定义，二叉树是连通的无环图，并且每个顶点的度不大于3</span>
              
                  * 完全二叉树<br>
	                  定义：而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树
	                 
	                   * 满二叉树<br>
	                     定义：一棵深度为k，且有 2^(k + 1) − 1 个节点的二叉树，称为满二叉树
	               * 平衡二叉树<br>
	                 定义：平衡二叉树一种结构平衡的二叉搜索树，即叶节点高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
	                 
	               * 排序二叉树（二叉搜索树）<br>
	                性质： 
	                  1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
                     2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
                     3. 任意节点的左、右子树也分别为二叉查找树；
                     4. 没有键值相等的节点

       
       
             * 哈夫曼树
             * B树

       [扩展](https://zh.wikipedia.org/wiki/树_(数据结构))      
       [树结构讲解](#树结构讲解)   
        
        * 二叉搜索树

  * 堆
  * 散列表
  * 图
* [算法](算法)
  * 计数排序
  * 基数排序
  * 插入排序
  * 快速排序  

	  * **快速排序思想**

		  1. 获取数组第一个数作为枢轴,将大于枢轴的元素放到右边,将小于枢轴的元素放到左边
		  2. 在枢轴左右两侧重新做快速排序

    * **快速排序复杂度**

		  1. 平均复杂度`O(NlogN)`
		  2. 最坏复杂度`O(N^2)`
		
    * **快速排序实现(伪代码)**
		
~~~
QUICKSORT(A, p, r)
    if p < r    
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q-1)
        QUICKSORT(A, q+1, r)

//将数组分为两部分，返回临界值下标
PARTITION(A, p, r)
    x = A[r]    //以最后一个数为主元（pivot element）
    i = p-1 //小于主元子数组的下标上限
    for j = p to r-1
        if A[j] <= x
            i = i+1 //增加小于主元子数组的大小
            exchange A[i] with A[j] //将A[j]加入小于主元的子数组
    exchange A[i+1] with A[r]   //将主元从数组末尾移动至子数组之间
    return i + 1  
~~~

[来源](http://harttle.land/2015/09/27/quick-sort.html)
		
   * **快速排序实现(java代码)**

~~~
public static void quickSort(int a[], int left, int right) {
    if (left >= 0 && right <= a.length - 1 && left < right) {
        int low = left,high = right,splitKey = a[left];
        while (left < right) {
            while (left < right && a[right] >= splitKey) right--;
            a[left] = a[right];
            while (left < right && a[left] <= splitKey) left++;
            a[right] = a[left];
        }
        a[left] = splitKey;//左右指针同时指向同一元素
        quickSort(a, low, left - 1);
        quickSort(a, left + 1, high);
    }
}
~~~

  * 桶排序
  * 堆排序
  * 算法复杂度分析
  
* 其他
  * 动态规划算法
  * 分治法算法
  * 贪心算法
  * 并行算法
  * 排序网络
  * 矩阵计算

  
  
<span id="树结构讲解">树结构讲解</span>  




